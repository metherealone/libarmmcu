/*
 * GPIO.cpp
 *
 *  Created on: Apr 4, 2014
 *      Author: Tolga HOŞGÖR
 */

#ifndef GPIO_CPP_
#define CPIO_CPP_

#include <GPIO.h>

namespace GPIO
{

template<Port port>
constexpr PortType<port> volatile* const getPort()
{
  return nullptr;
}

template<Port port>
template<uint8_t m_idx>
PortType<port>::Pin<m_idx>* PortType<port>::getPin() volatile
{
  return nullptr;
}

template<Port port>
template<uint8_t idx>
void PortType<port>::Pin<idx>::setMode(PortType::Pin<idx>::Mode const mode)
{
  reinterpret_cast<GPIO::PortType<port> volatile*>(port)->m_MODER &= ~(0x3 <<(idx * 2));
  reinterpret_cast<GPIO::PortType<port> volatile*>(port)->m_MODER |= static_cast<uint32_t>(mode) <<(idx * 2);
}

template<Port port>
template<uint8_t idx>
void PortType<port>::Pin<idx>::set()
{
  reinterpret_cast<GPIO::PortType<port> volatile*>(port)->m_BSRR |= static_cast<uint16_t>(0x1) <<idx;
}

template<Port port>
template<uint8_t idx>
void PortType<port>::Pin<idx>::reset()
{
  reinterpret_cast<GPIO::PortType<port> volatile*>(port)->m_BSRR |= static_cast<uint32_t>(0x1) <<(idx + 16);
}

template<Port port>
template<uint8_t idx>
bool PortType<port>::Pin<idx>::getInputState()
{
  return (reinterpret_cast<GPIO::PortType<port> volatile*>(port)->m_IDR & (static_cast<uint16_t>(0x1) <<idx));
}

template<Port port>
template<uint8_t idx>
bool PortType<port>::Pin<idx>::getOutputState()
{
  return (reinterpret_cast<GPIO::PortType<port> volatile*>(port)->m_ODR & (static_cast<uint16_t>(0x1) <<idx));
}

}

#endif /* GPIO_CPP_ */
