/*
 * GPIO.cpp
 *
 *  Created on: Apr 4, 2014
 *      Author: Tolga HOŞGÖR
 */

#ifndef GPIO_CPP_
#define CPIO_CPP_

#include <GPIO.h>

#include <type_traits>

namespace GPIO
{

template<std::size_t port>
constexpr Port<port> volatile* const getPort()
{
  return reinterpret_cast<Port<port> volatile*>(port);
}

template<std::size_t port>
template<uint8_t m_idx>
Port<port>::Pin<m_idx> Port<port>::getPin() volatile
{
  return Port<port>::Pin<m_idx>{};
}

template<std::size_t port>
template<uint8_t idx>
void Port<port>::Pin<idx>::setMode(Port::Pin<idx>::Mode const mode) volatile
{
  constexpr uint32_t shiftBy { (idx * 2) };
  reinterpret_cast<Port<port> volatile*>(port)->m_MODER &= ~(0x3 <<shiftBy);
  reinterpret_cast<Port<port> volatile*>(port)->m_MODER |= static_cast<uint32_t>(mode) <<shiftBy;
}

template<std::size_t port>
template<uint8_t idx>
template<uint8_t idx_>
typename std::enable_if<(idx_ < 8)>::type
  Port<port>::Pin<idx>::setAF_(AF const af) volatile
{
  constexpr uint32_t shiftBy{idx * 4};
  reinterpret_cast<Port<port> volatile*>(port)->m_AFRL &= ~(0x4 << shiftBy);
  reinterpret_cast<Port<port> volatile*>(port)->m_AFRL |= static_cast<uint32_t>(af) << shiftBy;
}

template<std::size_t port>
template<uint8_t idx>
template<uint8_t idx_>
typename std::enable_if<(idx_ >= 8 && idx_ <= 15)>::type
    Port<port>::Pin<idx>::setAF_(AF const af) volatile
{
  constexpr uint32_t shiftBy{idx * 4};
  reinterpret_cast<Port<port> volatile*>(port)->m_AFRH &= ~(0x4 << shiftBy);
  reinterpret_cast<Port<port> volatile*>(port)->m_AFRH |= static_cast<uint32_t>(af) << shiftBy;
}

template<std::size_t port>
template<uint8_t idx>
void Port<port>::Pin<idx>::setAF(Port::Pin<idx>::AF const af) volatile
{
  setAF_<idx>(af);
}

template<std::size_t port>
template<uint8_t idx>
void Port<port>::Pin<idx>::setOutputSpeed(Port::Pin<idx>::OutputSpeed const ospeed) volatile
{
  constexpr uint32_t shiftBy { idx * 2 };
  reinterpret_cast<Port<port> volatile*>(port)->m_OSPEEDR &= ~(0x3 <<shiftBy);
  reinterpret_cast<Port<port> volatile*>(port)->m_OSPEEDR |= static_cast<uint32_t>(ospeed) <<shiftBy;
}

template<std::size_t port>
template<uint8_t idx>
void Port<port>::Pin<idx>::setPushPullMode(Port::Pin<idx>::PushPullMode const ppm) volatile
{
  constexpr uint32_t shiftBy { idx * 2 };
  reinterpret_cast<Port<port> volatile*>(port)->m_PUPDR &= ~(0x3 <<shiftBy);
  reinterpret_cast<Port<port> volatile*>(port)->m_PUPDR |= static_cast<uint32_t>(ppm) <<shiftBy;
}

template<std::size_t port>
template<uint8_t idx>
void Port<port>::Pin<idx>::set() volatile
{
  reinterpret_cast<Port<port> volatile*>(port)->m_BSRR |= static_cast<uint16_t>(0x1) <<idx;
}

template<std::size_t port>
template<uint8_t idx>
void Port<port>::Pin<idx>::reset() volatile
{
  reinterpret_cast<Port<port> volatile*>(port)->m_BSRR |= static_cast<uint32_t>(0x1) <<(idx + 16);
}

template<std::size_t port>
template<uint8_t idx>
bool Port<port>::Pin<idx>::getInputState() volatile
{
  return (reinterpret_cast<Port<port> volatile*>(port)->m_IDR & (static_cast<uint16_t>(0x1) <<idx));
}

template<std::size_t port>
template<uint8_t idx>
bool Port<port>::Pin<idx>::getOutputState() volatile
{
  return (reinterpret_cast<Port<port> volatile*>(port)->m_ODR & (static_cast<uint16_t>(0x1) <<idx));
}

}

#endif /* GPIO_CPP_ */
