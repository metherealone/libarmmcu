/*
 * TIM.cpp
 *
 *  Created on: Apr 5, 2014
 *      Author: Tolga HOŞGÖR
 */

#ifndef TIM_CPP_
#define TIM_CPP_

#include <TIM.h>

namespace stm32f429
{
namespace TIM
{

template<std::size_t tim>
constexpr TIM<tim> volatile* const getTIM()
{
  return reinterpret_cast<TIM<tim> volatile*>(tim);
}

template<std::size_t tim>
void TIM<tim>::enable() volatile
{
  m_CR1 |= 0x1;
}

template<std::size_t tim>
void TIM<tim>::disable() volatile
{
  m_CR1 &= ~0x1;
}

template<std::size_t tim>
void TIM<tim>::setAutoReloadValue(uint16_t const value) volatile
{
  m_ARR = value;
}

template<std::size_t tim>
void TIM<tim>::setPrescalerValue(uint16_t const value) volatile
{
  m_PSC = value;
}

template<std::size_t tim>
uint16_t TIM<tim>::getCounterValue() volatile
{
  return m_CNT;
}

template<std::size_t tim>
template<uint8_t idx>
constexpr TIM<tim>::CC<idx> TIM<tim>::getCC() volatile
{
  return TIM<tim>::CC<idx>{};
}

template<std::size_t tim>
void TIM<tim>::enableUEV() volatile
{
  m_CR1 |= (0x1 <<1);
}

template<std::size_t tim>
void TIM<tim>::disableUEV() volatile
{
  m_CR1 &= ~(0x1 <<1);
}

template<std::size_t tim>
void TIM<tim>::setUEVSource(UEVSource const uEVSource) volatile
{
}

template<std::size_t tim>
void TIM<tim>::enableOnePulseMode() volatile
{
  m_CR1 |= 0x1 <<2;
}

template<std::size_t tim>
void TIM<tim>::disableOnePulseMode() volatile
{
  m_CR1 &= ~(0x1 <<2);
}

template<std::size_t tim>
void TIM<tim>::enableAutoReloadPreload() volatile
{
  m_CR1 |= 0x1 <<7;
}

template<std::size_t tim>
void TIM<tim>::disableAutoReloadPreload() volatile
{
  m_CR1 &= ~(0x1 <<7);
}

template<std::size_t tim>
void TIM<tim>::setMasterMode(TIM<tim>::MasterMode const mode) volatile
{
  auto newCR = m_CR2; //TODO: BURADAKİ TEMP GEREKLİ Mİ?
  newCR &= ~(0x7 <<4);
  newCR |= static_cast<uint32_t>(mode) <<4;
  m_CR2 = newCR;
}

template<std::size_t tim>
template<uint8_t idx>
void TIM<tim>::CC<idx>::enable() volatile
{
  reinterpret_cast<TIM<tim> volatile*>(tim)->m_CCER |= 0x1 <<((idx - 1) * 4);
}

template<std::size_t tim>
template<uint8_t idx>
void TIM<tim>::CC<idx>::disable() volatile
{
  reinterpret_cast<TIM<tim> volatile*>(tim)->m_CCER |= ~(0x1 <<((idx - 1) * 4));
}

template<std::size_t tim>
template<uint8_t idx>
void TIM<tim>::CC<idx>::setValue(uint32_t const value) volatile
{
  uint32_t volatile* CCR1 = &(reinterpret_cast<TIM<tim> volatile*>(tim)->m_CCR1);
  *(CCR1 + (idx - 1)) =  value;
}

template<std::size_t tim>
template<uint8_t idx>
void TIM<tim>::CC<idx>::setOCMode(TIM<tim>::CC<idx>::OCMode const mode) volatile
{
  setOCMode_<idx>(mode);
}

template<std::size_t tim>
template<uint8_t idx>
void TIM<tim>::CC<idx>::enableOCPreload() volatile
{
  enableOCPreload_<idx>();
}

template<std::size_t tim>
template<uint8_t idx>
template<uint8_t idx_>
typename std::enable_if<(idx >= 1 && idx_ <= 2)>::type
TIM<tim>::CC<idx>::setOCMode_(OCMode const mode) volatile
{
  constexpr uint8_t shiftBy{4 + (idx - 1) * 8};
  auto newCCMR = reinterpret_cast<TIM<tim> volatile*>(tim)->m_CCMR1;
  newCCMR &= ~(0x7 <<shiftBy);
  newCCMR |= static_cast<uint32_t>(mode) <<shiftBy;
  reinterpret_cast<TIM<tim> volatile*>(tim)->m_CCMR1 = newCCMR;
}

template<std::size_t tim>
template<uint8_t idx>
template<uint8_t idx_>
typename std::enable_if<(idx_ >= 3 && idx_ <= 4)>::type
TIM<tim>::CC<idx>::setOCMode_(OCMode const mode) volatile
{
  constexpr uint8_t shiftBy{4 + (idx - 3) * 8};
  auto newCCMR = reinterpret_cast<TIM<tim> volatile*>(tim)->m_CCMR2;
  newCCMR &= ~(0x7 <<shiftBy);
  newCCMR |= static_cast<uint32_t>(mode) <<shiftBy;
  reinterpret_cast<TIM<tim> volatile*>(tim)->m_CCMR2 = newCCMR;
}

template<std::size_t tim>
template<uint8_t idx>
template<uint8_t idx_>
typename std::enable_if<(idx_ >= 1 && idx_ <= 2)>::type
TIM<tim>::CC<idx>::enableOCPreload_() volatile
{
  constexpr uint8_t shiftBy{ 3 + (idx - 1) * 8};
  reinterpret_cast<TIM<tim> volatile*>(tim)->m_CCMR1 |= 0x1 <<shiftBy;
}

template<std::size_t tim>
template<uint8_t idx>
template<uint8_t idx_>
typename std::enable_if<(idx_ >= 3 && idx_ <= 4)>::type
TIM<tim>::CC<idx>::enableOCPreload_() volatile
{
  constexpr uint8_t shiftBy{ 3 + (idx - 3) * 8};
  reinterpret_cast<TIM<tim> volatile*>(tim)->m_CCMR2 |= 0x1 <<shiftBy;
}

template<std::size_t tim>
void TIM<tim>::enableUpdateDMARequest() volatile
{
  m_DIER |= 0x1 <<8;
}

template<std::size_t tim>
void TIM<tim>::disableUpdateDMARequest() volatile
{
  m_DIER &= ~(0x1 <<8);
}

template<std::size_t tim>
void TIM<tim>::enableUpdateInterrupt() volatile
{
  m_DIER |= 0x1;
}

template<std::size_t tim>
void TIM<tim>::disableUpdateInterrupt() volatile
{
  m_DIER &= ~0x1;
}

template<std::size_t tim>
bool TIM<tim>::getStatus() volatile
{
  return m_SR & 0x1;
}

template<std::size_t tim>
void TIM<tim>::clearStatus() volatile
{
  m_SR &= ~0x1;
}

template<std::size_t tim>
void TIM<tim>::generateEvent() volatile
{
  m_EGR |= 0x1;
}

} //NS TIM
} //NS stm32f429

#endif
