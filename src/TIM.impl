/*
 * TIM.cpp
 *
 *  Created on: Apr 5, 2014
 *      Author: Tolga HOŞGÖR
 */

#ifndef TIM_CPP_
#define TIM_CPP_

#include <TIM.h>

TIM volatile* const TIM::getTIM(TIM volatile* const tim)
{
  return tim;
}

void TIM::enable() volatile
{
  m_CR1 |= 0x1;
}

void TIM::disable() volatile
{
  m_CR1 &= ~0x1;
}

template<uint8_t CCChannel>
void TIM::enableCC() volatile
{
  m_CCER |= 0x1 <<((CCChannel - 1) * 4);
}

template<uint8_t CCChannel>
void TIM::disableCC() volatile
{
  m_CCER |= ~(0x1 <<((CCChannel - 1) * 4));
}

void TIM::setAutoReloadValue(uint16_t const value) volatile
{
  m_ARR = value;
}

void TIM::setPrescalerValue(uint16_t const value) volatile
{
  m_PSC = value;
}

template<>
void TIM::setCCValue<1>(uint32_t const value) volatile
{
  m_CCR1 = value;
}

template<>
void TIM::setCCValue<2>(uint32_t const value) volatile
{
  m_CCR2 = value;
}

template<>
void TIM::setCCValue<3>(uint32_t const value) volatile
{
  m_CCR3 = value;
}

template<>
void TIM::setCCValue<4>(uint32_t const value) volatile
{
  m_CCR4 = value;
}

uint16_t TIM::getCounterValue() volatile
{
  return m_CNT;
}

void TIM::enableUEV() volatile
{
  m_CR1 |= (0x1 <<1);
}

void TIM::disableUEV() volatile
{
  m_CR1 &= ~(0x1 <<1);
}

void TIM::setUEVSource(UEVSource const uEVSource) volatile
{
}

void TIM::enableOnePulseMode() volatile
{
  m_CR1 |= 0x1 <<2;
}

void TIM::disableOnePulseMode() volatile
{
  m_CR1 &= ~(0x1 <<2);
}

void TIM::enableAutoReloadPreload() volatile
{
  m_CR1 |= 0x1 <<7;
}

void TIM::disableAutoReloadPreload() volatile
{
  m_CR1 &= ~(0x1 <<7);
}

void TIM::setMasterMode(TIM::MasterMode const mode) volatile
{
  auto newCR = m_CR2; //TODO: BURADAKİ TEMP GEREKLİ Mİ?
  newCR &= ~(0x7 <<4);
  newCR |= static_cast<uint32_t>(mode) <<4;
  m_CR2 = newCR;
}

template<>
void TIM::setOCMode<1>(TIM::OCMode const mode) volatile
{
  auto newCCMR = m_CCMR1;
  newCCMR &= ~(0x7 <<4);
  newCCMR |= static_cast<uint32_t>(mode) <<4;
  m_CCMR1 = newCCMR;
}

template<>
void TIM::setOCMode<2>(TIM::OCMode const mode) volatile
{
  auto newCCMR = m_CCMR1;
  newCCMR &= ~(0x7 <<12);
  newCCMR |= static_cast<uint32_t>(mode) <<12;
  m_CCMR1 = newCCMR;
}

template<>
void TIM::setOCMode<3>(TIM::OCMode const mode) volatile
{
  auto newCCMR = m_CCMR2;
  newCCMR &= ~(0x7 <<4);
  newCCMR |= static_cast<uint32_t>(mode) <<4;
  m_CCMR2 = newCCMR;
}

template<>
void TIM::setOCMode<4>(TIM::OCMode const mode) volatile
{
  auto newCCMR = m_CCMR2;
  newCCMR &= ~(0x7 <<12);
  newCCMR |= static_cast<uint32_t>(mode) <<12;
  m_CCMR2 = newCCMR;
}

template<>
void TIM::enableOCPreload<1>() volatile
{
  m_CCMR1 |= 0x1 <<3;
}

template<>
void TIM::enableOCPreload<2>() volatile
{
  m_CCMR1 |= 0x1 <<11;
}

template<>
void TIM::enableOCPreload<3>() volatile
{
  m_CCMR2 |= 0x1 <<3;
}

template<>
void TIM::enableOCPreload<4>() volatile
{
  m_CCMR2 |= 0x1 <<11;
}

void TIM::enableUpdateDMARequest() volatile
{
  m_DIER |= 0x1 <<8;
}

void TIM::disableUpdateDMARequest() volatile
{
  m_DIER &= ~(0x1 <<8);
}

void TIM::enableUpdateInterrupt() volatile
{
  m_DIER |= 0x1;
}

void TIM::disableUpdateInterrupt() volatile
{
  m_DIER &= ~0x1;
}

bool TIM::getStatus() volatile
{
  return m_SR & 0x1;
}

void TIM::clearStatus() volatile
{
  m_SR &= ~0x1;
}

void TIM::generateEvent() volatile
{
  m_EGR |= 0x1;
}

#endif
