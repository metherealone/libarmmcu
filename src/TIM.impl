/*
 * TIM.cpp
 *
 *  Created on: Apr 5, 2014
 *      Author: Tolga HOŞGÖR
 */

#ifndef TIM_CPP_
#define TIM_CPP_

#include <TIM.h>

TIM volatile* const TIM::getTIM(TIM volatile* const tim)
{
  return tim;
}

void TIM::enable() volatile
{
  m_CR1 |= 0x1;
}

void TIM::disable() volatile
{
  m_CR1 &= ~0x1;
}

void TIM::setAutoReloadValue(uint16_t value) volatile
{
  m_ARR = value;
}

void TIM::setPrescalerValue(uint16_t value) volatile
{
  m_PSC = value;
}

uint16_t TIM::getCounterValue() volatile
{
  return m_CNT;
}

void TIM::enableUEV() volatile
{
  m_CR1 |= (0x1 <<1);
}

void TIM::disableUEV() volatile
{
  m_CR1 &= ~(0x1 <<1);
}

void TIM::setUEVSource(UEVSource uEVSource) volatile
{
}

void TIM::enableOnePulseMode() volatile
{
  m_CR1 |= 0x1 <<2;
}

void TIM::disableOnePulseMode() volatile
{
  m_CR1 &= ~(0x1 <<2);
}

void TIM::enableAutoReloadPreload() volatile
{
  m_CR1 |= 0x1 <<7;
}

void TIM::setMasterMode(TIM::MasterMode mode) volatile
{
  auto newCR2 = m_CR2; //TODO: BURADAKİ TEMP GEREKLİ Mİ?
  newCR2 &= ~(0x7 <<4);
  newCR2 |= static_cast<uint32_t>(mode) <<4;
  m_CR2 = newCR2;
}

void TIM::disableAutoReloadPreload() volatile
{
  m_CR1 &= ~(0x1 <<7);
}

void TIM::enableUpdateDMARequest() volatile
{
  m_DIER |= 0x1 <<8;
}

void TIM::disableUpdateDMARequest() volatile
{
  m_DIER &= ~(0x1 <<8);
}

void TIM::enableUpdateInterrupt() volatile
{
  m_DIER |= 0x1;
}

void TIM::disableUpdateInterrupt() volatile
{
  m_DIER &= ~0x1;
}

bool TIM::getStatus() volatile
{
  return m_SR & 0x1;
}

void TIM::clearStatus() volatile
{
  m_SR &= ~0x1;
}

void TIM::generateEvent() volatile
{
  m_EGR |= 0x1;
}

#endif
